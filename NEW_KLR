C:\Users\HariharaM12\PycharmProjects\T_2\.venv\Scripts\python.exe C:\Users\HariharaM12\PycharmProjects\T_2\main.py 
100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 517/517 [00:00<00:00, 706.71it/s]
100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 164/164 [00:24<00:00,  6.74it/s]
 Running batch 1...
‚ùå Batch 1 JSON parse error: Expecting value: line 1 column 1 (char 0)
üîé Raw response:
```json
[
  {
    "kappa_flc": "56.21 mg/dL",
    "lambda_flc": "<3.08 mg/dL",
    "kappa_lambda_ratio": ">115.57",
    "date_of_lab": "2024-02-22",
    "evidence_sentences": [
      "Latest Reference Range & Units 02/22/24 09:20   Kappa Free Light Chain 0.76 - 6.83 mg/dL 56.21 (H)   Lambda Free Light Chain 0.68 - 4.58 mg/dL <3.08 (L)   Kappa/Lambda FLC Ratio 0.66 - 2.22  >115.57 (H)"
    ]
  },
  {
    "kappa_flc": "203.94 mg/dL",
    "lambda_flc": "<0.15 mg/dL",
    "kappa_lambda_ratio": ">1456.71",
    "date_of_lab": "2024-02-08",
    "evidence_sentences": [
      "Free Light Chains   Result Value Ref Range    Kappa Free Light Chain 203.94 (H) 0.76 - 6.83 mg/dL    Lambda Free Light Chain <0.15 (L) 0.68 - 4.58 mg/dL    Kappa/Lambda FLC Ratio >1456.71 (H) 0.66 - 2.22"
    ]
  },
  {
    "kappa_flc": "20.78 mg/dL",
    "lambda_flc": "0.24 mg/dL",
    "kappa_lambda_ratio": "86.58",
    "date_of_lab": "2021-06-XX",
    "evidence_sentences": [
      "In 6/2021, he had kappa FLC of 20.78, lambda FLC of 0.24, kappa/lambda ratio of 86.58."
    ]
  }
]
```
 Running batch 2...
‚ùå Batch 2 JSON parse error: Expecting value: line 1 column 1 (char 0)
üîé Raw response:
```json
[]
```
 Running batch 3...
‚ùå Batch 3 JSON parse error: Expecting value: line 1 column 1 (char 0)
üîé Raw response:
```json
[
  {
    "kappa_flc": "129.54mg/dL",
    "lambda_flc": "15mg/dL",
    "kappa_lambda_ratio": ">914.29",
    "date_of_lab": "2023-11-28",
    "evidence_sentences": [
      "11/28/23: kappa free light chain (KFLC) 129.54mg /dL, lambda free light chain (LFLC) 15mg /dL, kappa/lambda ratio >914.29."
    ]
  }
]
```
 No results to save. The final DataFrame is empty or missing expected columns.

Process finished with exit code 0




import os
import re
import json
import pandas as pd
import configparser
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor, as_completed
from langchain_core.documents import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI

# --- Load config.ini ---
config = configparser.ConfigParser()
config.read("config.ini")

AZURE_OPENAI_API_KEY = config["azure_openai"]["api_key"]
AZURE_OPENAI_ENDPOINT = config["azure_openai"]["endpoint"]
AZURE_OPENAI_API_VERSION = config["azure_openai"]["api_version"]
EMBEDDING_DEPLOYMENT = config["embedding_models"]["text_embedding_3_large"]
EMBEDDING_MODEL = "text-embedding-3-large"
GPT_DEPLOYMENT = config["gpt_models"]["model_gpt4o"]

# --- Helpers ---
def parse_llm_json(raw_text: str) -> str:
    pattern = r"```(?:json)?\\s*(.*?)```"
    match = re.search(pattern, raw_text, flags=re.DOTALL)
    raw_text = match.group(1).strip() if match else raw_text.strip()
    if raw_text.startswith("json"):
        raw_text = raw_text[len("json"):].strip()
    try:
        parsed = json.loads(raw_text)
    except json.JSONDecodeError:
        fixed = raw_text.replace("'", '"')
        parsed = json.loads(fixed)
    return json.dumps(parsed)

def normalize_text(text):
    text = text.lower()
    text = re.sub(r'[^a-z0-9]', ' ', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

def clean_numeric(val: str) -> str:
    if not isinstance(val, str):
        return val
    match = re.search(r"[0-9]+\.?[0-9]*", val)
    return match.group(0) if match else ""

def enrich_value_with_units(value: str, evidence: str) -> str:
    if not value or not evidence:
        return value
    try:
        float_value = float(value)
    except:
        return value
    pattern = re.compile(rf"([<>]?\s*{re.escape(value)}\s*(?:mg/dl|mg/l)?)", re.IGNORECASE)
    match = pattern.search(evidence)
    return match.group(1).strip() if match else value

def batchify(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

# --- Load dataset ---
csv_path = "d2c1f46e2b3267d315fb03f76724aa7036ea01b3f1803e94126e26dc26881629.csv"
df = pd.read_csv(csv_path)

# --- Create documents ---
all_documents = []
for _, row in tqdm(df.iterrows(), total=len(df)):
    if pd.isna(row["text"]):
        continue
    text = row["text"]
    source = row["title"]
    word_count = len(text.split())
    if word_count < 500:
        chunk_size = 1000
        chunk_overlap = 0
    elif word_count < 2000:
        chunk_size = 1500
        chunk_overlap = 250
    else:
        chunk_size = 3000
        chunk_overlap = 500
    splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)
    chunks = splitter.split_text(text)
    all_documents.extend([Document(page_content=chunk, metadata={"source": source}) for chunk in chunks])

# --- Embedding & FAISS index ---
embedding_model = AzureOpenAIEmbeddings(
    deployment=EMBEDDING_DEPLOYMENT,
    model=EMBEDDING_MODEL,
    openai_api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    openai_api_version=AZURE_OPENAI_API_VERSION,
    chunk_size=1000
)

grouped_batches = list(batchify(all_documents, 10))
sub_indexes = []
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = {executor.submit(FAISS.from_documents, batch, embedding_model): batch for batch in grouped_batches}
    for future in tqdm(as_completed(futures), total=len(futures)):
        try:
            sub_indexes.append(future.result())
        except Exception as e:
            print(f"Batch failed: {e}")

main_index = sub_indexes[0]
for sub_index in sub_indexes[1:]:
    main_index.merge_from(sub_index)
main_index.save_local("faiss_index")

# --- Search relevant chunks ---
vectorstore = FAISS.load_local("faiss_index", embeddings=embedding_model, allow_dangerous_deserialization=True)
query = "Extract the patient's kappa free light chain (mg/L), lambda free light chain (mg/L), and kappa/lambda ratio, along with the lab date and evidence."
results = vectorstore.similarity_search(query, k=1000)

def has_all_markers(text):
    norm = text.lower()
    return all(term in norm for term in ["kappa", "lambda", "ratio"])

filtered_chunks = []
for doc in results:
    if has_all_markers(doc.page_content):
        filtered_chunks.append({"title": doc.metadata.get("source", "Unknown"), "content": doc.page_content})

# --- LLM setup ---
llm = AzureChatOpenAI(
    deployment_name=GPT_DEPLOYMENT,
    model_name="gpt-4o",
    openai_api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    openai_api_version=AZURE_OPENAI_API_VERSION,
    temperature=0
)

# --- Extraction ---
final_results = []
for i, batch in enumerate(batchify(filtered_chunks, 10)):
    json_context = [{"note_id": j + 1, "title": doc["title"], "content": doc["content"]} for j, doc in enumerate(batch)]
    titles = [doc["title"] for doc in batch]

    full_prompt = f"""
You are a clinical data extraction assistant. For the given document, extract the following **only if all values are explicitly present with correct units (mg/dL or mg/L)**:

- `kappa_flc`: Kappa free light chain (numeric + unit like mg/dL or mg/L)
- `lambda_flc`: Lambda free light chain (numeric + unit)
- `kappa_lambda_ratio`: The ratio value (can be raw number or include < or >)
- `date_of_lab`: If exact date found, use that. If partial (e.g. year only), format as:
  - 2024 ‚Üí 2024-XX-XX
  - 2023-05 ‚Üí 2023-05-XX
- `evidence_sentences`: Sentence(s) where **ALL 3 values are clearly mentioned**. Do not extract values unless this sentence confirms all 3.

üî¥ Do NOT guess or infer. If even one value is missing, SKIP.

Respond only in strict JSON format:
[
  {{
    "kappa_flc": "...",
    "lambda_flc": "...",
    "kappa_lambda_ratio": "...",
    "date_of_lab": "...",
    "evidence_sentences": ["...", "..."]
  }}
]

--- Context:
{json.dumps(json_context, indent=2)}
"""

    print(f"\n\U0001f9e0 Running batch {i+1}...")
    response = llm.invoke(full_prompt)

    if not response or not response.content.strip():
        print(f"‚ö†Ô∏è Empty response for batch {i+1}")
        continue

    try:
        cleaned = parse_llm_json(response.content)
        batch_result = json.loads(cleaned)
    except Exception as parse_error:
        print(f"‚ùå Batch {i+1} JSON parse error: {parse_error}")
        print("üîé Raw response:")
        print(response.content)
        continue

    for item, title in zip(batch_result, titles):
        evidence_text = " ".join(item.get("evidence_sentences", []))
        kappa = clean_numeric(item.get("kappa_flc", ""))
        lambda_ = clean_numeric(item.get("lambda_flc", ""))
        ratio = clean_numeric(item.get("kappa_lambda_ratio", ""))
        item["kappa_flc"] = enrich_value_with_units(kappa, evidence_text)
        item["lambda_flc"] = enrich_value_with_units(lambda_, evidence_text)
        item["kappa_lambda_ratio"] = enrich_value_with_units(ratio, evidence_text)
        item["source_document"] = title
        item["context"] = json.dumps(item, indent=2)

        if all(field in evidence_text.lower() for field in ["kappa", "lambda", "ratio"]):
            final_results.append(item)

# --- Save results ---
df = pd.DataFrame(final_results)
cols = ["source_document", "kappa_flc", "lambda_flc", "kappa_lambda_ratio", "date_of_lab", "evidence_sentences", "context"]

if not df.empty and all(col in df.columns for col in cols):
    df = df[cols]
    df.drop_duplicates(subset=["kappa_flc", "lambda_flc", "kappa_lambda_ratio"], keep='first', inplace=True)
    os.makedirs("output", exist_ok=True)
    df.to_excel("output/Output_with_units_enriched.xlsx", index=False)
    df.to_json("output/Output_with_units_enriched.json", orient="records", indent=2)
    print("\n\u2705 Output saved to 'output/' folder")
else:
    print("\u26a0\ufe0f No results to save. The final DataFrame is empty or missing expected columns.")
