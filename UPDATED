import os
import re
import json
import pandas as pd
import configparser
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor, as_completed
from langchain_core.documents import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI

# Load config
config = configparser.ConfigParser()
config.read("config.ini")

# Azure credentials
AZURE_OPENAI_API_KEY = config["azure_openai"]["api_key"]
AZURE_OPENAI_ENDPOINT = config["azure_openai"]["endpoint"]
AZURE_OPENAI_API_VERSION = config["azure_openai"]["api_version"]
EMBEDDING_DEPLOYMENT = config["embedding_models"]["text_embedding_3_large"]
EMBEDDING_MODEL = "text-embedding-3-large"
GPT_DEPLOYMENT = config["gpt_models"]["model_gpt4o"]

# Paths
csv_path = "d2c1f46e2b3267d315fb03f76724aa7036ea01b3f1803e94126e26dc26881629.csv"
output_dir = r"C:\Users\HariharaM12\PycharmProjects\Rag1\Task"
os.makedirs(output_dir, exist_ok=True)
output_path = os.path.join(output_dir, "extracted_results.xlsx")

# Helpers
def batchify(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

def parse_llm_json(raw_text: str) -> str:
    pattern = r"```(?:json)?\s*(.*?)```"
    match = re.search(pattern, raw_text, flags=re.DOTALL)
    raw_text = match.group(1).strip() if match else raw_text.strip()
    if raw_text.startswith("json"):
        raw_text = raw_text[len("json"):].strip()
    try:
        parsed = json.loads(raw_text)
    except json.JSONDecodeError:
        fixed = raw_text.replace("'", '"')
        parsed = json.loads(fixed)
    return json.dumps(parsed)

def normalize_text(text):
    text = text.lower()
    text = re.sub(r'[^a-z0-9]', ' ', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

def extract_numeric(value):
    if not isinstance(value, str):
        return value
    match = re.search(r"[\d.]+", value.replace(',', ''))
    return match.group(0) if match else ""

# Load and prepare documents
df = pd.read_csv(csv_path)
documents = [
    Document(page_content=row["text"], metadata={"source": row["title"]})
    for _, row in df.iterrows() if pd.notna(row["text"])
]

# Split into chunks
splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=250)
chunks = splitter.split_documents(documents)
chunk_batches = list(batchify(chunks, 20))

# Setup embedding
embedding_model = AzureOpenAIEmbeddings(
    deployment=EMBEDDING_DEPLOYMENT,
    model=EMBEDDING_MODEL,
    openai_api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    openai_api_version=AZURE_OPENAI_API_VERSION,
    chunk_size=1000
)

# Build FAISS index in parallel
def build_faiss(batch):
    return FAISS.from_documents(batch, embedding_model)

sub_indexes = []
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = {executor.submit(build_faiss, batch): batch for batch in chunk_batches}
    for future in tqdm(as_completed(futures), total=len(futures)):
        try:
            sub_indexes.append(future.result())
        except Exception as e:
            print(f"Batch failed: {e}")

main_index = sub_indexes[0]
for sub_index in sub_indexes[1:]:
    main_index.merge_from(sub_index)
main_index.save_local("faiss_index")

# Query FAISS
vectorstore = FAISS.load_local("faiss_index", embeddings=embedding_model, allow_dangerous_deserialization=True)
query = "Extract the patient's kappa free light chain (mg/L), lambda free light chain (mg/L), and kappa/lambda ratio, along with the lab date and evidence."
results = vectorstore.similarity_search(query, k=1000)

# Filter relevant chunks
filtered_chunks = []
for doc in results:
    norm = normalize_text(doc.page_content)
    if 'kappa' in norm or 'lambda' in norm or 'ratio' in norm:
        filtered_chunks.append((doc.metadata.get("source", "Unknown"), doc.page_content))

# LLM setup
llm = AzureChatOpenAI(
    deployment_name=GPT_DEPLOYMENT,
    model_name="gpt-4o",
    openai_api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    openai_api_version=AZURE_OPENAI_API_VERSION,
    temperature=0
)

# Prepare prompt batches
final_results = []
batches = list(batchify(filtered_chunks, 10))
for i, batch in enumerate(batches):
    context = "\n\n".join(f"Note {i + 1} from {source}::\n{doc}" for i, (source, doc) in enumerate(batch))
    prompt = f"""
You are a medical information extraction assistant. Your task is to extract lab results from the provided clinical notes.

From the context below, extract the following values **only if they are explicitly mentioned**:
- Kappa free light chains (mg/L)
- Lambda free light chains (mg/L)
- Kappa/Lambda ratio
- Lab test date (YYYY-MM-DD format)
- Supporting evidence sentence
- The document title the sentence came from (you will be given that)

IMPORTANT:
- If the date is incomplete (e.g., only month and year), fill the missing parts with "XX".
- DO NOT guess or infer dates.
- Return structured JSON list. One object per lab result.
- Include "evidence_sentences" and "source_document".

[
  {{
    "kappa_flc": "<value with unit>",
    "lambda_flc": "<value with unit>",
    "kappa_lambda_ratio": "<numeric ratio>",
    "date_of_lab": "<YYYY-MM-DD or with XX>",
    "evidence_sentences": ["<sentence>"],
    "source_document": "<document title>"
  }}
]

--- CONTEXT START ---
{context}
--- CONTEXT END ---
"""
    try:
        print(f"\nüß† Batch {i + 1}/{len(batches)}")
        response = llm.invoke(prompt)
        cleaned = parse_llm_json(response.content)
        extracted_items = json.loads(cleaned)

        for item, (source_title, _) in zip(extracted_items, batch):
            item["source_document"] = source_title
            item["context"] = json.dumps({
                "kappa_flc": item.get("kappa_flc", ""),
                "lambda_flc": item.get("lambda_flc", ""),
                "kappa_lambda_ratio": item.get("kappa_lambda_ratio", ""),
                "date_of_lab": item.get("date_of_lab", ""),
                "evidence_sentences": item.get("evidence_sentences", [])
            })
            final_results.append(item)

    except Exception as e:
        print(f"‚ùå Failed batch {i + 1}: {e}")

# Save cleaned file
if final_results:
    df = pd.DataFrame(final_results)
    df["evidence_sentences"] = df["evidence_sentences"].apply(lambda x: "\n".join(x) if isinstance(x, list) else str(x))
    for col in ["kappa_flc", "lambda_flc", "kappa_lambda_ratio"]:
        df[col] = df[col].apply(extract_numeric)
    df = df.drop_duplicates(subset=["kappa_flc", "lambda_flc", "kappa_lambda_ratio"])
    column_order = ["source_document", "kappa_flc", "lambda_flc", "kappa_lambda_ratio", "date_of_lab", "evidence_sentences", "context"]
    df = df[column_order]
    df.to_excel(output_path, index=False)
    print(f"\n‚úÖ Saved at: {output_path}")
else:
    print("‚ö†Ô∏è No data extracted.")

    # --- Save just the "context" column to a separate JSONL file ---
    context_output_path = os.path.join(output_dir, "extracted_contexts.jsonl")

    with open(context_output_path, "w", encoding="utf-8") as f:
        for ctx in df["context"]:
            f.write(ctx + "\n")

    print(f"üìù Contexts saved to: {context_output_path}")





import os
import re
import json
import pandas as pd
import configparser
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor, as_completed
from langchain_core.documents import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI

# Load config
config = configparser.ConfigParser()
config.read("config.ini")

# Azure credentials
AZURE_OPENAI_API_KEY = config["azure_openai"]["api_key"]
AZURE_OPENAI_ENDPOINT = config["azure_openai"]["endpoint"]
AZURE_OPENAI_API_VERSION = config["azure_openai"]["api_version"]
EMBEDDING_DEPLOYMENT = config["embedding_models"]["text_embedding_3_large"]
EMBEDDING_MODEL = "text-embedding-3-large"
GPT_DEPLOYMENT = config["gpt_models"]["model_gpt4o"]

# Paths
csv_path = "d2c1f46e2b3267d315fb03f76724aa7036ea01b3f1803e94126e26dc26881629.csv"
output_dir = r"C:\\Users\\HariharaM12\\PycharmProjects\\Rag1\\Task"
os.makedirs(output_dir, exist_ok=True)
output_path = os.path.join(output_dir, "extracted_results.xlsx")

# Helpers
def batchify(lst, n):
    for i in range(0, len(lst), n):
        yield lst[i:i + n]

def parse_llm_json(raw_text: str) -> str:
    pattern = r"```(?:json)?\s*(.*?)```"
    match = re.search(pattern, raw_text, flags=re.DOTALL)
    raw_text = match.group(1).strip() if match else raw_text.strip()
    if raw_text.startswith("json"):
        raw_text = raw_text[len("json"):].strip()
    try:
        parsed = json.loads(raw_text)
    except json.JSONDecodeError:
        fixed = raw_text.replace("'", '"')
        parsed = json.loads(fixed)
    return json.dumps(parsed)

def normalize_text(text):
    text = text.lower()
    text = re.sub(r'[^a-z0-9]', ' ', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

def get_value_with_unit_loose(field_value, context_text, field_name):
    if not field_value or not context_text:
        return field_value

    try:
        number_pattern = r"[<>]?[\s]*[\d]+(?:\.\d+)?"
        if field_name in ["kappa_flc", "lambda_flc"]:
            unit_pattern = rf"({number_pattern}[\s]*(mg/dl|mg/l))"
        else:
            unit_pattern = rf"({number_pattern})"

        matches = re.findall(unit_pattern, context_text, re.IGNORECASE)
        for match in matches:
            full_match = match[0] if isinstance(match, tuple) else match
            cleaned = re.sub(r'[<>\s]', '', full_match)
            if cleaned.startswith(field_value.replace('.', '')) or field_value in cleaned:
                return full_match.replace(" ", "")
    except:
        return field_value
    return field_value

def flatten_context(context_json):
    obj = json.loads(context_json)
    return " ".join(str(v) if not isinstance(v, list) else " ".join(v) for v in obj.values())

# Load and prepare documents
df = pd.read_csv(csv_path)
documents = [
    Document(page_content=row["text"], metadata={"source": row["title"]})
    for _, row in df.iterrows() if pd.notna(row["text"])
]

# Split into chunks
splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=250)
chunks = splitter.split_documents(documents)
chunk_batches = list(batchify(chunks, 20))

# Setup embedding
embedding_model = AzureOpenAIEmbeddings(
    deployment=EMBEDDING_DEPLOYMENT,
    model=EMBEDDING_MODEL,
    openai_api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    openai_api_version=AZURE_OPENAI_API_VERSION,
    chunk_size=1000
)

# Build FAISS index in parallel
def build_faiss(batch):
    return FAISS.from_documents(batch, embedding_model)

sub_indexes = []
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = {executor.submit(build_faiss, batch): batch for batch in chunk_batches}
    for future in tqdm(as_completed(futures), total=len(futures)):
        try:
            sub_indexes.append(future.result())
        except Exception as e:
            print(f"Batch failed: {e}")

main_index = sub_indexes[0]
for sub_index in sub_indexes[1:]:
    main_index.merge_from(sub_index)
main_index.save_local("faiss_index")

# Query FAISS
vectorstore = FAISS.load_local("faiss_index", embeddings=embedding_model, allow_dangerous_deserialization=True)
query = "Extract the patient's kappa free light chain (mg/L), lambda free light chain (mg/L), and kappa/lambda ratio, along with the lab date and evidence."
results = vectorstore.similarity_search(query, k=1000)

# Filter relevant chunks
filtered_chunks = []
for doc in results:
    norm = normalize_text(doc.page_content)
    if 'kappa' in norm or 'lambda' in norm or 'ratio' in norm:
        filtered_chunks.append((doc.metadata.get("source", "Unknown"), doc.page_content))

# LLM setup
llm = AzureChatOpenAI(
    deployment_name=GPT_DEPLOYMENT,
    model_name="gpt-4o",
    openai_api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    openai_api_version=AZURE_OPENAI_API_VERSION,
    temperature=0
)

# Prepare prompt batches
final_results = []
batches = list(batchify(filtered_chunks, 10))
for i, batch in enumerate(batches):
    context = "\n\n".join(f"Note {i + 1} from {source}::\n{doc}" for i, (source, doc) in enumerate(batch))
    prompt = f"""
You are a medical information extraction assistant. Your task is to extract lab results from the provided clinical notes.

From the context below, extract the following values **only if they are explicitly mentioned**:
- Kappa free light chains (mg/L)
- Lambda free light chains (mg/L)
- Kappa/Lambda ratio
- Lab test date (YYYY-MM-DD format)
- Supporting evidence sentence
- The document title the sentence came from (you will be given that)

IMPORTANT:
- If the date is incomplete (e.g., only month and year), fill the missing parts with "XX".
- DO NOT guess or infer dates.
- Return structured JSON list. One object per lab result.
- Include "evidence_sentences" and "source_document".

[
  {{
    "kappa_flc": "<value with unit>",
    "lambda_flc": "<value with unit>",
    "kappa_lambda_ratio": "<numeric ratio>",
    "date_of_lab": "<YYYY-MM-DD or with XX>",
    "evidence_sentences": ["<sentence>"],
    "source_document": "<document title>"
  }}
]

--- CONTEXT START ---
{context}
--- CONTEXT END ---
"""
    try:
        print(f"\nüß† Batch {i + 1}/{len(batches)}")
        response = llm.invoke(prompt)
        cleaned = parse_llm_json(response.content)
        extracted_items = json.loads(cleaned)

        for item, (source_title, _) in zip(extracted_items, batch):
            item["source_document"] = source_title
            item["context"] = json.dumps({
                "kappa_flc": item.get("kappa_flc", ""),
                "lambda_flc": item.get("lambda_flc", ""),
                "kappa_lambda_ratio": item.get("kappa_lambda_ratio", ""),
                "date_of_lab": item.get("date_of_lab", ""),
                "evidence_sentences": item.get("evidence_sentences", [])
            })
            final_results.append(item)

    except Exception as e:
        print(f"‚ùå Failed batch {i + 1}: {e}")

# Save cleaned file
if final_results:
    df = pd.DataFrame(final_results)
    df["evidence_sentences"] = df["evidence_sentences"].apply(lambda x: "\n".join(x) if isinstance(x, list) else str(x))

    # Restore symbols and units from context
    for i, row in df.iterrows():
        context_text = flatten_context(row["context"])
        df.at[i, "kappa_flc"] = get_value_with_unit_loose(str(row["kappa_flc"]), context_text, "kappa_flc")
        df.at[i, "lambda_flc"] = get_value_with_unit_loose(str(row["lambda_flc"]), context_text, "lambda_flc")
        df.at[i, "kappa_lambda_ratio"] = get_value_with_unit_loose(str(row["kappa_lambda_ratio"]), context_text, "kappa_lambda_ratio")

    df = df.drop_duplicates(subset=["kappa_flc", "lambda_flc", "kappa_lambda_ratio"])
    column_order = ["source_document", "kappa_flc", "lambda_flc", "kappa_lambda_ratio", "date_of_lab", "evidence_sentences", "context"]
    df = df[column_order]

    df.to_excel(output_path, index=False)
    print(f"\n‚úÖ Saved at: {output_path}")

    # Also save context to .jsonl
    context_output_path = os.path.join(output_dir, "extracted_contexts.jsonl")
    with open(context_output_path, "w", encoding="utf-8") as f:
        for ctx in df["context"]:
            f.write(ctx + "\n")
    print(f"üìù Contexts saved to: {context_output_path}")
else:
    print("‚ö†Ô∏è No data extracted.")
